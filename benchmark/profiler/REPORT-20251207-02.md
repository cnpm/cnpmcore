# CPU Profile Analysis Report - 02-x-cpuprofile-3070674-20251207

- **Profile**: `02-x-cpuprofile-3070674-20251207-0.cpuprofile`
- **Date**: 2025-12-07
- **Duration**: 180.01 seconds (3 minutes)
- **Profile Type**: `xprofiler-cpu-profile`
- **Process ID**: 3070674

## Executive Summary

This CPU profile was captured from a cnpmcore production instance. The application shows **very low CPU utilization** (1.8% active time), indicating it's mostly waiting on I/O operations. When the CPU is active, **Leoric ORM's Bone constructor is the dominant hotspot** at 12.4% of active time.

### Key Metrics

| Metric | Value |
|--------|-------|
| Total Samples | 168,658 |
| Active CPU Time | 1.8% (3,061 samples) |
| Idle Time | 97.7% |
| GC Time | 0.2% (345 samples) |
| Program Time | 0.3% |

### Key Findings

1. **Excellent overall efficiency** - Only 1.8% CPU utilization with 0.2% GC overhead
2. **Leoric ORM dominates active time** - 24.4% of active CPU is in leoric package
3. **Bone constructor is the #1 hotspot** - 12.4% of active time in a single function
4. **Application code is well-optimized** - Only 2.5% of active time in app code

## CPU Time Distribution

### By State

```
Total Samples: 168,658
├── Idle:     164,808 (97.72%) ████████████████████████████████████████
├── Active:     3,061 ( 1.81%) █
├── Program:      444 ( 0.26%)
└── GC:           345 ( 0.20%)
```

### Active Time by Category

```
Active Samples: 3,061
├── NPM Packages:     1,828 (59.72%) ████████████████████████
├── Node.js Core:       647 (21.14%) ████████
├── Native/V8:          509 (16.63%) ██████
└── Application Code:    77 ( 2.52%) █
```

## Top Performance Hotspots

### 1. Leoric ORM - Bone Constructor (12.41%)

**The single biggest CPU consumer** is the `Bone` constructor, which is called every time a database row is converted to an ORM entity.

| Rank | Function | Samples | % Active |
|------|----------|---------|----------|
| 1 | Bone (constructor) | 380 | 12.41% |
| 5 | dispatch (Collection) | 47 | 1.54% |
| 6 | instantiate | 36 | 1.18% |
| 15 | Bone (create path) | 27 | 0.88% |

**Location**: `node_modules/leoric@2.13.9@leoric/lib/bone.js:150`

**Root Causes**:
1. Each database row instantiates a new Bone object
2. The constructor performs property initialization and metadata setup
3. Bulk queries (like `listBinaries`) create many Bone instances

**Call Paths**:
```
Database Query → ignite() → dispatch() → instantiate() → Bone()
Entity Create  → create() → ContextModelClass → Bone()
```

**Application Entry Points Triggering Bone**:
- `convertEntityToModel` (34 hits) - Task creation
- `convertModelToEntity` (10 hits) - Binary queries
- `findBinary` (5 hits) - Binary lookups
- `listBinaries` (6 hits) - Directory listings

### 2. urllib JSON Parsing (3.82%)

| Function | Samples | % Active |
|----------|---------|----------|
| parseJSON | 117 | 3.82% |

**Location**: `node_modules/urllib@4.8.2@urllib/dist/esm/utils.js:25`

This is standard JSON parsing for HTTP responses. Relatively high due to the volume of registry API calls.

### 3. Native I/O Operations (5.90%)

| Function | Samples | % Active |
|----------|---------|----------|
| writeSync | 72 | 2.35% |
| structuredClone | 42 | 1.37% |
| writeBuffer | 40 | 1.31% |
| writev | 37 | 1.21% |

These are expected for a registry serving packages. Network and disk I/O is fundamental to the application's function.

### 4. MySQL2 Driver (6.11%)

| Function | Samples | % Active |
|----------|---------|----------|
| column_definition.get | 36 | 1.18% |
| query.start | 31 | 1.01% |
| keyFromFields | 20 | 0.65% |
| createQuery | 10 | 0.33% |

Normal database driver operations. The time is proportional to query volume.

## Application Code Analysis

Application code represents only **2.52%** of active CPU time - excellent efficiency.

### Top Application Functions

| Rank | Function | File | Samples | % |
|------|----------|------|---------|---|
| 1 | convertModelToEntity | ModelConvertor.js:74 | 15 | 0.49% |
| 2 | listBinaries | BinaryRepository.js:33 | 6 | 0.20% |
| 3 | showBinary | BinarySyncController.js:38 | 7 | 0.23% |
| 4 | findBinary | BinarySyncerService.js:30 | 3 | 0.10% |
| 5 | Tracing middleware | Tracing.js:1 | 4 | 0.13% |

### Observation

The application logic is very lean. Most CPU time is delegated to well-optimized NPM packages.

## Module CPU Consumption

| Rank | Module | Samples | % Active |
|------|--------|---------|----------|
| 1 | leoric | 747 | 24.40% |
| 2 | (native) | 509 | 16.63% |
| 3 | mysql2 | 187 | 6.11% |
| 4 | urllib | 137 | 4.48% |
| 5 | @eggjs/tegg-runtime | 101 | 3.30% |
| 6 | @eggjs/koa | 66 | 2.16% |
| 7 | @eggjs/lifecycle | 50 | 1.63% |
| 8 | @eggjs/router | 46 | 1.50% |
| 9 | reflect-metadata | 40 | 1.31% |
| 10 | egg-logger | 32 | 1.05% |

## Comparison with Previous Profile

| Metric | Previous (REPORT.md) | Current | Change |
|--------|---------------------|---------|--------|
| Active CPU % | 6.02% | 1.81% | ↓ 70% |
| GC % | 2.91% | 0.20% | ↓ 93% |
| Bone % of Active | 15.38% | 12.41% | ↓ 19% |
| App Code % | 2.18% | 2.52% | ↑ 16% |

**Notable Improvements**:
- Significantly lower CPU utilization overall
- Much lower GC pressure (likely from Leoric optimization in version 2.13.9)
- Bone constructor is still the hotspot but improved

## Recommendations

### High Priority

1. **Optimize Bone Instantiation for Bulk Queries**

   The recent Leoric 2.13.9 update (PR #919: "avoids Bone constructor overhead for each row") should help. Verify this optimization is active:

   ```javascript
   // Check if using .toJSON() instead of instantiation for read-only queries
   const rows = await Model.find().toJSON();  // Avoids Bone instantiation
   ```

2. **Consider Raw Queries for Batch Operations**

   For bulk read operations like `listBinaries`, consider using raw SQL when entity methods aren't needed:

   ```javascript
   // Instead of: Model.find({ where: conditions })
   // Use: Model.query('SELECT * FROM binaries WHERE ...').spread(rows => rows)
   ```

### Medium Priority

3. **Monitor JSON Parsing**

   The `parseJSON` function at 3.82% indicates significant upstream API communication. Ensure:
   - HTTP responses use gzip compression
   - Consider caching frequently fetched data

4. **Profile Specific Endpoints**

   Based on the call tree, these endpoints are worth individual profiling:
   - `/binary` endpoints (showBinary, listBinaries)
   - Task creation operations

### Low Priority

5. **Current Performance is Excellent**
   - 97.7% idle time indicates the application is I/O bound
   - 0.2% GC time is outstanding for Node.js
   - Application code at 2.5% shows good architecture

## Analysis Tools

### Available Scripts

| Script | Description | Usage |
|--------|-------------|-------|
| `analyze-profile.js` | Comprehensive analysis | `node analyze-profile.js <profile>` |
| `hotspot-finder.js` | Find specific hotspots | `node hotspot-finder.js <profile> --filter=leoric` |
| `call-tree-analyzer.js` | Trace call paths | `node call-tree-analyzer.js <profile> --target=Bone` |
| `flamegraph-convert.js` | Convert for flame graphs | `node flamegraph-convert.js <profile> > stacks.txt` |
| `quick-summary.js` | One-page summary | `node quick-summary.js <profile>` |

### Viewing the Profile

1. **Chrome DevTools**: `chrome://inspect` → Performance tab → Load
2. **speedscope.app**: Upload at https://www.speedscope.app/
3. **VS Code**: Use "vscode-js-profile-flame" extension

## Conclusion

The cnpmcore instance is running very efficiently with only 1.8% CPU utilization. The main optimization opportunity remains in the Leoric ORM's Bone constructor, though recent versions have improved this. The GC overhead is minimal at 0.2%, indicating good memory management.

**Key Takeaway**: The application is I/O bound (97.7% idle), which is expected for a registry service. When CPU is active, Leoric ORM dominates at 24.4%. The recent Leoric 2.13.9 update targeting Bone constructor overhead should help further optimize this hotspot.
